<!DOCTYPE html>
<html>
<head>
  <title>Pedigree</title>
</head>
<body>
  <script type="text/javascript">
    var row_id = 1;
    var pedigree = [];
    function indiv(name, sex, infected, father, mother) {
      this.name = name;
      this.sex = sex;
      this.prob = infected;
      this.father = father;
      this.mother = mother;
    }
    indiv.prototype.toString = function indivToString() {
      return this.name+','+this.sex+','+this.prob+','+this.father+','+this.mother;
    }
    function add_row() {
      // append a row
      var list = document.getElementById('list');
      var text = '<div id=row'+row_id.toString()+' class="indiv">\
        Name: <input type="text" name="name" value="Bob">\
        Sex: <select name="sex">\
          <option value="m">male</option>\
          <option value="f">female</option>\
        </select>\
        Probability: <input type="number" name="prob">\
        Father: <input type="text" name="father" value="">\
        Mother: <input type="text" name="mother" value="">\
        <button onclick="delete_row(\'row'+row_id.toString()+'\');">Delete Individual</button>\
      </div>';
      list.insertAdjacentHTML('beforeend', text);
      row_id++;
    }
    function delete_row(rowid) {
      // delete a row
      var row = document.getElementById(rowid);
      row.parentNode.removeChild(row);
    }
    function build() {
      // transform HTML list into pedigree array
      pedigree = [];
      var rows = document.getElementById('list').childNodes;
      for (var i = 0; i < rows.length; i++) {
        row = rows[i].childNodes;
        name = row[1].value;
        if (row[1].value == '') {
          alert('error: undefined name');
          return -1;
        }
        sex = row[3].value;
        prob = parseFloat(row[5].value);
        if (row[5].value == '') {
          alert('error: undefined probability');
          return -1;
        }
        father = row[7].value;
        mother = row[9].value;
        pedigree.push(new indiv(name, sex, prob, father, mother));
      }
      return 1;
    }
    function verify() {
      // verify that the pedigree is valid
      // we can afford to be inefficient, since pedigrees are small
      for (var i = 0; i < pedigree.length; i++) {
        // no duplicates
        for (var j = 0; j < pedigree.length; j++) {
          if (pedigree[i].name == pedigree[j].name && i != j) {
            window.alert('error: duplicate individual found');
            return -1;
          }
        }

        // parents either both exist or both don't exist
        if ((pedigree[i].father != '' && pedigree[i].mother == '') ||
            (pedigree[i].father == '' && pedigree[i].mother != '')) {
              window.alert('error: each individual must have exactly 0 or 2 parents');
              return -1;
            }
        else if (pedigree[i].father != '' && pedigree[i].mother != '') {
          found_parents = 0;
          for (var j = 0; j < pedigree.length; j++) {
            if ((pedigree[i].father == pedigree[j].name || pedigree[i].mother == pedigree[j].name) && i != j) {
              found_parents++;
            }
          }
          if (found_parents < 2) {
            window.alert('error: specified parents not found in pedigree');
            return -1;
          }
        } else {
          // founder has independent probability
          if (pedigree[i].prob < 0) {
            window.alert('error: founders must have independent probability');
            return -1;
          }
        }

        //probability is in range [0, 1]
        if ((pedigree[i].father == '' && pedigree[i].prob < 0) ||
            pedigree[i].prob > 1) {
              window.alert('error: probabilities must be in range [0, 1]')
              return -1;
            }

        // father must be male and mother must be female
        // at this point, we have already checked that someone is not his or
        // her own parent
        for (var j = 0; j < pedigree.length; j++) {
          if ((pedigree[i].father == pedigree[j].name && pedigree[j].sex == 'f') || (pedigree[i].mother == pedigree[j].name && pedigree[j].sex == 'm')) {
            window.alert('error: father must be male and mother must be female');
            return -1;
          }
        }
      }
      return 1;
    }
    function render() {
      // request the server to build the pedigree
      var query = '?';
      for (var i = 0; i < pedigree.length; i++) {
        if (i > 0) {
          query += '&';
        }
        query += 'p'+i.toString()+'='+pedigree[i].toString();
      }
      img = document.getElementById('ped-img');
      img.src = 'cgi-bin/pedigree'+query;
      console.log(query)
    }
    function make_ped() {
      // put together all the little functions
      if (build() > 0 && verify() > 0) {
        //yay for short-circuiting!

        // error messages already provided by verify()
        render();
      }
    }
  </script>
  <div id="instructions">
    <p>Welcome to Linnaeus: the online pedigree maker!</p><br>
    <p>Instructions: add or delete individuals as you like and define relationships among them. The probability of infection must be between 0 and 1, although a child is permitted to have an unknown probability (-1) as long as the parent probabilities are known (and this applies recursively). Leave parents blank if this person has no parents in the pedigree. Note that individuals are identified by name, so you cannot have a duplicate name.</p>
    <p>Note that this only graphs families; if there is an individual without a family, he or she will not be plotted</p>
    <p>This is currently highly unstable: a good-looking pedigree might look terrible if you add or subtract a single person. This is mostly a proof-of-concept.</p>
  </div>
  <div id="buttons">
    <button onclick="add_row();">Add Individual</button>
    <button onclick="make_ped();">Build Pedigree</button>
  </div>
  <div id="list"></div>
  <div id="ped"><img id="ped-img" src=""></div>
</body>
</html>
