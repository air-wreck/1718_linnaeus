<!DOCTYPE html>
<html>

<!-- pedigree.html

Very plain page for web-based pedigree stuff
-->

<head>
  <title>Pedigree</title>
  <link rel="stylesheet" type="text/css" href="css/main.css">
  <link rel="stylesheet" type="text/css" href="css/pedigree.css">

  <!-- menu bar -->
  <script type="text/javascript" src="js/nav.js"></script>
  <!-- custom JS styles -->
  <script type="text/javascript" src="js/pretty.js"></script>

  <!-- pedigree scripts -->
  <script type="text/javascript" src="js/ped_solve.js"></script>
  <script type="text/javascript" src="js/ped_draw.js"></script>
  <script type="text/javascript" src="js/other/viz.js"></script>
  <script type="text/javascript" src="js/other/full.js.opaque"></script>
</head>
<body>
  <script type="text/javascript">
    let row_id = 1;  // the next available row_id
    let pedigree = [];  // a list of individuals present with all their data

    /* functions for generating, validating, and rendering pedigree */
    const add_row = () => {
      // append a row
      let list = document.getElementById("list");
      let text = `<div id="row${row_id.toString()}" class="indiv">
        Name: ${pretty.input("id='name"+row_id.toString()
          +"' type='text' name='name' value='Bob'").outerHTML}
        Sex: <select id="sex${row_id.toString()}" name="sex">
          <option value="m">male</option>
          <option value="f">female</option>
        </select>
        Probability: ${pretty.input("id='prob"+row_id.toString()
          +"' type='number' name='prob' style='width: 50px;' step='0.01' "
          +"min='-1' max='1'").outerHTML}
        Father: ${pretty.input("id='father"+row_id.toString()
          +"' type='text' name='father' value=''").outerHTML}
        Mother: ${pretty.input("id='mother"+row_id.toString()
          +"' type='text' name='mother' value=''").outerHTML}
        <button class="button delete-button"
          onclick="delete_row('row${row_id.toString()}');">
          Delete Individual
        </button>`
      list.insertAdjacentHTML("beforeend", text);
      row_id++;
    }

    const delete_row = rowid => {
      // delete a row
      let row = document.getElementById(rowid);
      row.parentNode.removeChild(row);
    }

    const build = () => {
      // transform HTML list into pedigree array
      pedigree = [];  // reset pedigree
      let rows = document.getElementById("list").childNodes;

      row_nums = Array.from(document.getElementById("list").childNodes)
        .filter(el => el.className === "indiv")
        .map(el => el.id.slice(3));
      if (row_nums.map(n => {
        let name = document.getElementById("name" + n).value;
        if (name === "") {
          // all names must be non-empty
          pretty.warn_user("Undefined name");
          return -1;
        }

        let sex = ped_solve.Sex.m;
        if (document.getElementById("sex" + n).value === "f")
          sex = ped_solve.Sex.f;

        let prob = parseFloat(document.getElementById("prob" + n).value);
        if (document.getElementById("prob" + n).value === "") {
          // all probabilities must be non-empty
          pretty.warn_user("Undefined probability (use -1 if unknown)");
          return -1;
        }

        // we're all good, now push to pedigree
        pedigree.push(new ped_solve.Person(name, sex, infected=prob));
        return 1;

      }).includes(-1)) return -1; // an error occurred somewhere inside

      // now that we have all individuals, associate everyone with parents
      // we have already done some error checking by this point
      row_nums.forEach(n => {
        let name = document.getElementById("name" + n).value;
        let child = pedigree[pedigree.findIndex(x => x.name === name)];
        let father = document.getElementById("father" + n).value;
        let mother = document.getElementById("mother" + n).value;
        if (father !== "" && mother !== "") {
          // find these parents in the array and associate them with child
          child.add_parents(
            pedigree[pedigree.findIndex(x => x.name === father)],
            pedigree[pedigree.findIndex(x => x.name === mother)]);
        }
      });

      return 1;  // success!
    }

    const verify = () => {
      // verify that the pedigree is valid
      // we can afford to be inefficient, since pedigrees are small

      // is there even anyone in the pedigree?
      if (pedigree.length === 0) {
        pretty.warn_user("No individuals found");
        return -1;
      }

      return pedigree.map(person => {
        const count = name =>
          pedigree.reduce((acc, x) => name === x.name ? acc+1 : acc, 0);

        // no duplicates
        if (count(person.name) > 1) {
          pretty.warn_user("Duplicate individual found");
          return -1;
        }

        // different checks based on number of parents
        if (person.father === null && person.mother === null) {
          // check for independent probability
          if (person.infected < 0) {
            pretty.warn_user("Founder must have independent probability");
            return -1;
          }

        } else if ([person.father, person.mother].includes(null)) {
          // INVALID: only one parent specified
          pretty.warn_user("Each individual must have exactly 0 or 2 parents");
          return -1;

        } else {
          // check for existence of father and mother
          if (!person.father || !person.mother) {
            pretty.warn_user("Specified parents not found in pedigree");
            return -1;
          }
        }

        // probability in range [0, 1]
        if ((person.father === null && person.infected) < 0
         || person.infected > 1) {
          pretty.warn_user("Probabilities must be in range [0, 1]");
          return -1;
        }

        // father and mother have proper biological sexes
        // at this point, an individual is guaranteed not to be his
        //   own parent
        if (person.father !== null && pedigree.some(x =>
           (person.father.name === x.name && x.sex === ped_solve.Sex.f
         || person.mother.name === x.name && x.sex === ped_solve.Sex.m))) {
          pretty.warn_user("Father must be male and mother must be female");
          return -1;
        }
      }).includes(-1) ? -1 : 1;
    }

    let viz = new Viz();
    const render = () => {
      // solve pedigree
      pedigree.forEach(ped_solve.find_prob);

      // identify all marriages
      // we assume that all relationships are monogamous and generational
      let marriages = [];
      pedigree
        .filter(indiv => indiv.father !== null)
        .map(indiv => {
          // has this marriage already been found?
          // i.e. is this a sibling of an already found child?
          if (!marriages.some(union => {
            if (union[0] === indiv.father && union[1] === indiv.mother) {
              union[2].push(indiv);
              return true;
            }
            return false;
          })) marriages.push([indiv.father, indiv.mother, [indiv]]);
        });

      // generate DOT string description
      let draw = new ped_draw.Draw("example");
      marriages.forEach(marriage => draw.draw_marriage(...marriage));

      // render on page
      viz.renderSVGElement(draw.render()).then(new_el => {
        new_el.id = "ped-img";
        let old_el = document.getElementById("ped-img");
        old_el.parentNode.replaceChild(new_el, old_el);
      });
    }

    const make_ped = () => {
      // put together all the little functions
      if (build() > 0 && verify() > 0) {
        //yay for short-circuiting!
        // error messages already provided by verify()
        render();
      }
    }
  </script>
  <div id="instructions">
    <div style="text-align: center;">
      <h1>Welcome to Linnaeus: the online pedigree maker!</h1>
    </div><br>

    <div id="blanket" style="display:none"></div>
    <div class="content-21" id="popUpDiv" style="display:none">
      <p><h2>How To Read a Pedigree</h2>
      <ul>
        <li>A circle represents a female.</li><br>
        <li>A square represents a male.</li><br>
        <li>Two parents are connected by a horizontal line.</li><br>
        <li>A vertical line leads to the offspring of two parents.</li><br>
        <li>A fully shaded circle/square represents an affected individual.</li><br>
        <li>A partially shaded circle/square represents a carrier<sup>1</sup>.</li>
      </ul>
      <br><sup>1</sup> A <strong>carrier</strong> is an individual who has one allele for a disease but does not exhibit the affected phenotype. However, he/she can potentially pass the disease on to offspring.</p>
      </p>
      <a href="#" onclick="popup('popUpDiv')" ><center class="button">Close</center></a>
    </div>
    <a href="#" onclick="popup('popUpDiv')"><center class="notice"><strong><u>Help! I can't interpret my pedigree!</u></strong></center><br></a>

    <script>
    function toggle(div_id) {
      var el = document.getElementById(div_id);
      if ( el.style.display == 'none' ) { el.style.display = 'block';}
      else {el.style.display = 'none';}
    }
    function blanket_size(popUpDivVar) {
      blanket_height = document.body.parentNode.scrollHeight;  
      var blanket = document.getElementById('blanket');
      blanket.style.height = blanket_height + 'px';
      var popUpDiv = document.getElementById(popUpDivVar);
      popUpDiv_height=blanket_height/2-(blanket_height*.2);
      popUpDiv.style.top = popUpDiv_height + 'px';
    }

    function window_pos(popUpDivVar) {
      window_width = document.body.parentNode.scrollWidth;
      var popUpDiv = document.getElementById(popUpDivVar);
      window_width=window_width/2-(window_width*.1);
      popUpDiv.style.left = window_width + 'px';
    }

    function popup(windowname) {
      blanket_size(windowname);
      window_pos(windowname);
      toggle('blanket');
      toggle(windowname);
    }
    </script>

    <div class="notice"><strong><u>Instructions:</u></strong> add or delete individuals as you like and define relationships among them. The probability of infection must be between 0 and 1, although a child is permitted to have an unknown probability (-1) as long as he or she has parents. Leave parents blank if this person has no parents in the pedigree. Note that individuals are identified by name (case sensitive), so you cannot have a duplicate name.</div>
    <p>Note that this only graphs families; if there is an individual without a family, he or she will not be plotted</p>
    <p>This is currently highly unstable: a good-looking pedigree might look terrible if you add or subtract a single person. This is mostly a proof-of-concept.</p>
  </div>

  <!-- container for the image, retrieved from the server -->
  <div id="ped">
    <!-- error message, which starts out hidden -->
    <div id="alert" class="alert" style="display: none;"><strong style="color: #b73000;"><b>Error: </b></strong><span id="alert-text"></span><span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span></div><br>
    <!-- the actual rendered pedigree -->
    <svg id="ped-img"></svg>
  </div>

  <!-- buttons on top for user interaction -->
  <div id="buttons">
    <button class="button" onclick="add_row();">Add Individual</button>
    <button class="button" onclick="make_ped();">Build Pedigree</button>
    <button class="button" onclick="download_ped();">Download as Image</button>
  </div>

  <!-- div storing the list of individuals -->
  <div id="list"></div>

  <!-- download rendered pedigree SVG as a PNG image -->
  <script type="text/javascript">
    let canvas = document.createElement("canvas");
    let link = document.createElement("a");
    const download_ped = () => {
      // possibly check if the pedigree has been rendered yet?
      let svgURL = new XMLSerializer().serializeToString(
        document.getElementById("ped-img"));
      let img = new Image();
      img.src = "data:image/svg+xml; charset=utf8, "
        + encodeURIComponent(svgURL);
      img.onload = event => {
        canvas.width = event.target.width;
        canvas.height = event.target.height;
        canvas.getContext("2d").drawImage(event.target, 0, 0);
        link.setAttribute("download", "linnaeus_pedigree.png");
        link.setAttribute("href",
          canvas.toDataURL().replace("image/png", "image/octet-stream"));
        link.click();
      }
    }
  </script>

  <!-- FOR EASIER TESTING -->
  <script type="text/javascript">
  // if this window has parameter ?mode=testing, add entires automatically
  if (window.location.href.split("").includes("?")
   && window.location.href.split("?")[1].split("").includes("=")
   && window.location.href.split("?")[1].split("=")[0] === "mode"
   && window.location.href.split("?")[1].split("=")[1] === "testing") {
    window.addEventListener("load", _ => {
      console.log("you are in ?mode=testing. test entries have been added.");
      let name = ["a", "b", "c"];
      let sex = ["m", "f", "m"];
      let prob = [1, 1, -1];
      let dad = ["", "", "a"];
      let mom = ["", "", "b"];

      [...Array(3).keys()].map(n => n+1).forEach(n => {
        add_row();
        document.getElementById("name"+n).value = name[n-1];
        document.getElementById("sex"+n).value = sex[n-1];
        document.getElementById("prob"+n).value = prob[n-1];
        document.getElementById("father"+n).value = dad[n-1];
        document.getElementById("mother"+n).value = mom[n-1];
      });
    });
  }
  </script>

</body>
</html>
