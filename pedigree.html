<!DOCTYPE html>
<html>

<!-- pedigree.html

Very plain page for web-based pedigree stuff
-->

<head>
  <title>Pedigree</title>
  <link rel="stylesheet" type="text/css" href="css/main.css">
  <link rel="stylesheet" type="text/css" href="css/pedigree.css">

  <!-- menu bar -->
  <script type="text/javascript" src="js/nav.js"></script>
  <!-- custom warning box -->
  <script type="text/javascript" src="js/warn.js"></script>

  <!-- pedigree scripts -->
  <script type="text/javascript" src="js/ped_solve.js"></script>
  <script type="text/javascript" src="js/ped_draw.js"></script>
  <script type="text/javascript" src="js/other/viz.js"></script>
  <script type="text/javascript" src="js/other/full.js.opaque"></script>
</head>
<body>
  <script type="text/javascript">
    let row_id = 1;  // the next available row_id
    let pedigree = [];  // a list of individuals present with all their data

    /* functions for generating, validating, and rendering pedigree */
    const add_row = () => {
      // append a row
      let list = document.getElementById("list");
      let text = `<div id="row${row_id.toString()}" class="indiv">
        Name: <input type="text" name="name" value="Bob">
        Sex: <select name="sex">
          <option value="m">male</option>
          <option value="f">female</option>
        </select>
        Probability: <input type="number" name="prob" style="width: 50px;">
        Father: <input type="text" name="father" value="">
        Mother: <input type="text" name="mother" value="">
        <button class="button delete-button"
          onclick="delete_row('row${row_id.toString()}');">
          Delete Individual
        </button>`
      list.insertAdjacentHTML("beforeend", text);
      row_id++;
    }

    const delete_row = rowid => {
      // delete a row
      let row = document.getElementById(rowid);
      row.parentNode.removeChild(row);
    }

    const build = () => {
      // transform HTML list into pedigree array
      pedigree = [];  // reset pedigree
      let rows = document.getElementById("list").childNodes;

      // first get all individuals
      for (let i = 0; i < rows.length; i++) {
        row = rows[i].childNodes;

        name = row[1].value;
        if (row[1].value === "") {
          // all names must be non-empty
          warn_user("Undefined name");
          return -1;
        }

        sex = Sex.m;
        if (row[3].value === "f")
          sex = Sex.f;

        prob = parseFloat(row[5].value);
        if (row[5].value === "") {
          // all probabilities must be non-empty
          warn_user("Undefined probability (use -1 if unknown)");
          return -1;
        }

        let p = new Person(name, sex, infected=prob);
        pedigree.push(new Person(name, sex, infected=prob));
      }

      // now that we have all individuals, associate everyone with parents
      Array.from(rows).map((row, i) => {
        let child = pedigree[i];
        let father = row.childNodes[7].value;
        let mother = row.childNodes[9].value;

        if (father !== "" && mother !== "") {
          // find these parents in the array and associate them with child
          child.add_parents(
            pedigree[pedigree.findIndex(x => x.name === father)],
            pedigree[pedigree.findIndex(x => x.name === mother)]);
        }
      });

      return 1;  // success!
    }

    const verify = () => {
      // verify that the pedigree is valid
      // we can afford to be inefficient, since pedigrees are small

      // is there even anyone in the pedigree?
      if (pedigree.length === 0) {
        warn_user("No individuals found");
        return -1;
      }

      // check further conditions for each individual in the pedigree
      for (let i = 0; i < pedigree.length; i++) {

        // no duplicates
        if (pedigree.some((x, j) =>
          pedigree[i].name === x.name && i !== j
          ? true : false
        )) {
          warn_user("Duplicate individual found");
          return -1;
        }

        // parents either both exist or both don't exist
        if ((pedigree[i].father !== null && pedigree[i].mother === null) ||
            (pedigree[i].father === null && pedigree[i].mother !== null)) {
              warn_user("Each individual must have exactly 0 or 2 parents");
              return -1;
            }
        else if (pedigree[i].father !== null
              && pedigree[i].mother !== null) {
          /*
          found_parents = 0;
          for (let j = 0; j < pedigree.length; j++) {
            if ((pedigree[i].father === pedigree[j].name || pedigree[i].mother === pedigree[j].name) && i !== j) {
              found_parents++;
            }
          }
          if (found_parents < 2) {
            warn_user('Specified parents not found in pedigree');
            return -1;
          }
          */
        } else {
          // founder has independent probability
          if (pedigree[i].infected < 0) {
            warn_user("Founders must have independent probability");
            return -1;
          }
        }

        //probability is in range [0, 1]
        if ((pedigree[i].father === null && pedigree[i].infected < 0) ||
            pedigree[i].infected > 1) {
              warn_user("Probabilities must be in range [0, 1]");
              return -1;
            }

        // father must be male and mother must be female
        // at this point, we have already checked that someone is not his or
        // her own parent
        if (pedigree[i].father !== null && pedigree.some(x =>
            (pedigree[i].father.name === x.name && x.sex === Sex.f
          || pedigree[i].mother.name === x.name && x.sex === Sex.m)
          ? true : false
        )) {
          warn_user("Father must be male and mother must be female");
          return -1;
        }
      }

      return 1;  // all good
    }

    let viz = new Viz();
    const render = () => {
      // solve pedigree
      for (let i = 0; i < pedigree.length; i++)
        find_prob(pedigree[i]);

      // identify all marriages
      // we assume that all relationships are monogamous and generational
      let marriages = [];
      pedigree
        .filter(indiv => indiv.father !== null)
        .map(indiv => {
          // has this marriage already been found?
          // i.e. is this a sibling of an already found child?
          if (!marriages.some(union => {
            if (union[0] == indiv.father && union[1] == indiv.mother) {
              union[2].push(indiv);
              return true;
            }
            return false;
          })) marriages.push([indiv.father, indiv.mother, [indiv]]);
        });

      // generate DOT string description
      let draw = new Draw('example');
      marriages.map(x => draw.draw_marriage(x[0], x[1], x[2]));

      // render on page
      viz.renderSVGElement(draw.render()).then(el => {
        el.id = "ped-img";
        document.getElementById("ped-img").outerHTML = el.outerHTML;
      });
    }

    const make_ped = () => {
      // put together all the little functions
      if (build() > 0 && verify() > 0) {
        //yay for short-circuiting!
        // error messages already provided by verify()
        render();
      }
    }
  </script>
  <div id="instructions">
    <div style="text-align: center;"><h1>Welcome to Linnaeus: the online pedigree maker!</h1></div><br>
    <div class="notice"><strong><u>Instructions:</u></strong> add or delete individuals as you like and define relationships among them. The probability of infection must be between 0 and 1, although a child is permitted to have an unknown probability (-1) as long as he or she has parents. Leave parents blank if this person has no parents in the pedigree. Note that individuals are identified by name (case sensitive), so you cannot have a duplicate name.</div>
    <p>Note that this only graphs families; if there is an individual without a family, he or she will not be plotted</p>
    <p>This is currently highly unstable: a good-looking pedigree might look terrible if you add or subtract a single person. This is mostly a proof-of-concept.</p>
  </div>

  <!-- container for the image, retrieved from the server -->
  <div id="ped">
    <!-- error message, which starts out hidden -->
    <div id="alert" class="alert" style="display: none;"><strong style="color: #b73000;"><b>Error: </b></strong><span id="alert-text"></span><span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span></div><br>
    <!-- the actual rendered pedigree -->
    <svg id="ped-img"></svg>
  </div>

  <!-- buttons on top for user interaction -->
  <div id="buttons">
    <button class="button" onclick="add_row();">Add Individual</button>
    <button class="button" onclick="make_ped();">Build Pedigree</button>
    <button class="button" onclick="download_ped();">Download as Image</button>
  </div>

  <!-- div storing the list of individuals -->
  <div id="list"></div>

  <!-- download rendered pedigree SVG as a PNG image -->
  <script type="text/javascript">
    let canvas = document.createElement("canvas");
    let link = document.createElement("a");
    const download_ped = () => {
      // possibly check if the pedigree has been rendered yet?
      let svgURL = new XMLSerializer().serializeToString(document.getElementById("ped-img"));
      let img = new Image();
      img.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(svgURL);
      img.onload = event => {
        canvas.width = event.target.width;
        canvas.height = event.target.height;
        canvas.getContext("2d").drawImage(event.target, 0, 0);
        link.setAttribute("download", "linnaeus_pedigree.png");
        link.setAttribute("href", canvas.toDataURL().replace("image/png", "image/octet-stream"));
        link.click();
      }
    }
  </script>

  <!-- FOR EASIER TESTING -->
  <script type="text/javascript">
  window.addEventListener("load", _ => {
    let name = ["a", "b", "c"];
    let sex = ["m", "f", "m"];
    let prob = [1, 1, -1];
    let dad = ["", "", "a"];
    let mom = ["", "", "b"];

    [...Array(3).keys()].forEach(n => {
      add_row();
      Array.from(document.getElementById("row" + (n+1)).childNodes).forEach(input => {
        if (input.name === "name") input.value = name[n];
        if (input.name === "sex") input.value = sex[n];
        if (input.name === "prob") input.value = prob[n];
        if (input.name === "father") input.value = dad[n];
        if (input.name === "mother") input.value = mom[n];
      });
    });
  });
  </script>
</body>
</html>
