#!/usr/bin/env python

# there is some hard link trickery going on here
# hopefully this is cross-system workable
import cgitb
import matplotlib.pyplot as plt
import numpy as np

# TEMPORARY CODE:
# I'm really desparate, so I'm just going to dump all this here until I find
# a working workaround

class colortbl():
    header_color = '#c6c6c6'

    def __init__(self, data):
        # save a copy of the data
        self.data = data

        # init axes
        ncols, nrows = len(data[0]), len(data)+1
        width, height = 0.1*(2*np.log2(ncols-1)+2), 0.3
        self.fig, self.axes = plt.subplots(ncols=ncols, nrows=nrows-1,
                                           figsize=(ncols*width, nrows*height))
        # may have to adjust margins for super large tables, but not an issue
        self.fig.subplots_adjust(0.05, 0.05, 0.95, 0.95, wspace=0, hspace=0)
        self.fig.subplots_adjust(top=1.0-(1.0/(len(self.data)+1)))

        # set styling
        for ax in self.axes.flatten():
            ax.tick_params(labelbottom=0, labelleft=0, bottom=0,
                           top=0, left=0, right=0)
            ax.axis('tight')

        # write in data and colorize headers
        for r, _ in enumerate(self.axes):
            self.color(r, 0, c1=self.header_color)
            for c, _ in enumerate(self.axes[0]):
                self.color(0, c, c1=self.header_color)
                self.add_text(str(data[r][c]), r, c)

    def title(self, text):
        self.fig.suptitle(text)

    def add_text(self, text, row, col):
        # in case manual override of text is needed
        self.axes[row][col].text(0.5, 0.5, text,
                                 transform=self.axes[row][col].transAxes,
                                 ha='center', va='center')

    def color(self, row, col, c1='#fcaba4', c2=None, c3=None, c4=None):
        # colorize cell; currently supports up to four colors
        cell = self.axes[row][col]
        lim1, lim2 = 0.06, 0.02
        if c2 == None:
            # if only one color given, set whole cell to that color
            cell.set_facecolor(c1)
        elif c3 == None:
            # if two colors given, split the cell
            cell.add_patch(
                plt.Polygon([[-lim1, -lim1], [lim1, -lim1], [lim1, lim1]],
                            color=c1)
            )
            cell.add_patch(
                plt.Polygon([[-lim1, -lim1], [-lim1, lim1], [lim1, lim1]],
                            color=c2)
            )
        elif c4 == None:
            # if three colors given, make a French flag
            cell.add_patch(
                plt.Polygon([[-lim1, -lim1], [-lim1, lim1], [-lim2, lim1],
                             [-lim2, -lim1]], color=c1)
            )
            cell.add_patch(
                plt.Polygon([[-lim2, lim1], [lim2, lim1], [lim2, -lim1],
                             [-lim2, -lim1]], color=c2)
            )
            cell.add_patch(
                plt.Polygon([[lim1, lim1], [lim1, -lim1], [lim2, -lim1],
                             [lim2, lim1]], color=c3)
            )
        else:
            # if four colors given, make an 'X' shape
            cell.add_patch(
                plt.Polygon([[-lim1, -lim1], [-lim1, lim1], [0, 0]], color=c1)
            )
            cell.add_patch(
                plt.Polygon([[-lim1, lim1], [lim1, lim1], [0, 0]], color=c2)
            )
            cell.add_patch(
                plt.Polygon([[lim1, lim1], [lim1, -lim1], [0, 0]], color=c3)
            )
            cell.add_patch(
                plt.Polygon([[lim1, -lim1], [-lim1, -lim1], [0, 0]], color=c4)
            )

    def show(self):
        plt.show()

    def to_png(self):
        plt.savefig('colortable.png')
        return file('colortable.png', 'r').read()

class allele:
    def __init__(self, name):
        self.name = name
    def __add__(self, other):
        return allele(self.name + other.name)
    def __mul__(self, other):
        # WARNING: two alleles being multiplied MUST have same length
        # use addition if untrue
        return allele(''.join([self.name[i]+other.name[i] for i, _ in
                               enumerate(self.name)]))
    def __repr__(self):
        return self.name

def str2geno(string):
    res = []
    for i in range(0, len(string), 2):
        res += [[allele(string[i]), allele(string[i+1])]]
    return res

def combine(arr, depth):
    if depth == len(arr):
        return [allele('')]
    return [i+j for i in arr[depth] for j in combine(arr, depth+1)]

def solve(f, m):
    f_arr, m_arr = combine(str2geno(f), 0), combine(str2geno(m), 0)
    sol_arr = np.outer(m_arr, f_arr).tolist()
    square = [[allele('')] + f_arr]
    nrows = len(f_arr) + 1
    for i in range(nrows-1):
        square += [[m_arr[i]] + sol_arr[i]]
    return square

def plot(f, m, title=''):
    square = solve(f, m)
    table = colortbl(square)
    table.title(title)
    return table

# these will be retrieved from HTTP POST once this is working okay
father = 'Aa'
mother = 'Aa'

# plot the punnett square
psquare = plot(father, mother, title='example')
psquare.color(1, 1, c1='#a4c4fc')
psquare.color(2, 2, c1='#fcaba4')
psquare.color(1, 2, c1='#fcaba4', c2='#a4c4fc')
psquare.color(2, 1, c1='#fcaba4', c2='#a4c4fc')

x = np.linspace(0, 2*np.pi)
y = np.cos(x)
plt.plot(x, y)
plt.savefig('colortable.png')

# print the image to stdout
cgitb.enable()
print 'Content-Type: image/png'
print ''
# print psquare.to_png()
print file('colortable.png', 'r').read()
